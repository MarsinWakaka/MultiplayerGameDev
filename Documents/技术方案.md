# 技术方案：

## 5.对象复制
* Entity：
  * uid，用于联机LinkingContext正确绑定对象
  * entityType: 实体类型，用于告知客户端对象的类型（一个类应当有独一无二的type）
    * 处理实体类型的handler应当是动态注册的，因为这是网络层，不应该依赖gameplay层的代码。
* LinkingContext:
  * AddGameObject(GameObject go, int netID) : void
  * RemoveGameObject(GameObject go) : void
  * GetGameObjectID(GameObject go, bool createIfNotFound) : int
* GhostManager:



### 数据包的设计
1. 对象标识符
2. 对象类型符
3. 序列化数据
* RA_Peplication\Create\Destory\MAX(枚举的最大值，防止出现意想不到的事情)

1. Create: CreationRegistry.get(classId) -> 添加至linkingContext
……

可能的错误处理：
* 如果对象数据包中，可能由于网络的不可靠，导致客户端没有部分对象，在后续的Update动作里，就会获取不到该对象从而无法进行操作，这种情况需要特殊处理。

### 5.5 RPC最为序列化对象


## 7. 延迟、抖动、可靠性
### 7.1 延迟
* 网络延迟
* 
* 输入采样延迟
* 渲染流水线延迟
* 多线程渲染线程延迟
* 垂直同步
* 显示延迟
* 像素响应时间
#### 网络延迟
1. 处理延迟
2. 传输延迟
3. 排队延迟
4. 传播延迟

### 7.2抖动
### 7.3数据包丢失
* 路由器满时，会抛弃队列中的数据包或者刚传入的数据包，但是路由器通常是以数据包个数为基础，所以发送少量的大数据包会比发送大量的小数据包更能减少丢包的概率。（还能降低排队延迟）
### 7.4 可靠性
* TCP 还是 UDP